{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 6,
   "id": "worse-wales",
   "metadata": {},
   "outputs": [],
   "source": [
    "def print_scores(y_test, y_hat_test, X_test, y_train, y_hat_train, X_train, model):\n",
    "    print('_____________________________________________________')\n",
    "    print('Training Accuracy Score : ' + str(accuracy_score(y_train, y_hat_train).round(4) * 100)[:5] + '%')\n",
    "    print('Training Precision Score : ' + str(precision_score(y_train, y_hat_train).round(4) * 100)[:5] + '%')\n",
    "    print('Training Recall Score : ' + str(recall_score(y_train, y_hat_train).round(4) * 100)[:5] + '%')\n",
    "    print('Training F1 Score : ' + str(f1_score(y_train, y_hat_train).round(4) * 100)[:5] + '%')\n",
    "    print('_____________________________________________________')\n",
    "    trainresiduals = np.abs(y_train - y_hat_train)\n",
    "    print('Training residual count:')\n",
    "    print(str(pd.Series(trainresiduals).value_counts())[:-29])\n",
    "    print('Training percentage correct: ' + str(pd.Series(trainresiduals).value_counts(normalize=True).round(4)*100)[7:-45])\n",
    "    print('_____________________________________________________')\n",
    "    print('Testing Accuracy Score : ' + str(accuracy_score(y_test, y_hat_test).round(4) * 100)[:5] + '%')\n",
    "    print('Testing Precision Score : ' + str(precision_score(y_test, y_hat_test).round(4) * 100)[:5] + '%')\n",
    "    print('Testing Recall Score : ' + str(recall_score(y_test, y_hat_test).round(4) * 100)[:5] + '%')\n",
    "    print('Testing F1 Score : ' + str(f1_score(y_test, y_hat_test).round(4) * 100)[:5] + '%')\n",
    "    print('_____________________________________________________')\n",
    "    testresiduals = np.abs(y_test - y_hat_test)\n",
    "    print('Testing residual count:')\n",
    "    print(str(pd.Series(testresiduals).value_counts())[:-29])\n",
    "    print('Testing percentage correct: ' + str(pd.Series(testresiduals).value_counts(normalize=True).round(4)*100)[7:-45])\n",
    "    print('_____________________________________________________')\n",
    "    print('                                                     ')\n",
    "    print('Cross validated model accuracy:')\n",
    "    print('Testing:')\n",
    "    scores = cross_val_score(model, X_test, y_test, cv=5)\n",
    "    print('%0.2f with a standard deviation of %0.2f' % (scores.mean(), scores.std()))\n",
    "    print('Training:')\n",
    "    scores = cross_val_score(model, X_train, y_train, cv=5)\n",
    "    print('%0.2f with a standard deviation of %0.2f' % (scores.mean(), scores.std()))\n",
    "    print('_____________________________________________________')\n",
    "    r2_scoretst = r2_score(y_test, y_hat_test)\n",
    "    print(f'Testing R2 Score: {r2_scoretst}')\n",
    "    r2_scoretrn = r2_score(y_train, y_hat_train)\n",
    "    print(f'Testing R2 Score: {r2_scoretrn}')    "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "id": "proprietary-graduate",
   "metadata": {},
   "outputs": [],
   "source": [
    "def findOtherName(check, primary, alts):\n",
    "    \"\"\"extract other names & ID number and arrange them in formatting that matches current standard stellar naming conventions\n",
    "    ex: stars['altnames'] = ['11 com b', 'Gliese 234', 'HD137'] -> stars['HD'] = '137'\"\"\"\n",
    "    name = \"\"\n",
    "    if primary.startswith(check):\n",
    "        name = primary[len(check) + 1:]\n",
    "    if name == \"\" and alts == \"\":\n",
    "        return np.nan\n",
    "    for i in range(len(alts)):\n",
    "        if alts[i].startswith(check):\n",
    "            name = alts[i][len(check) + 1:]\n",
    "    if name == \"\":\n",
    "        return np.nan\n",
    "    while re.search(\"\\D\", name):\n",
    "        name = name[:-1]\n",
    "    return float(name)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "id": "systematic-beach",
   "metadata": {},
   "outputs": [],
   "source": [
    "def findGLName(primary, alts):\n",
    "    \"\"\"extract Gliese name & ID number and arrange them in formatting that matches current standard stellar naming conventions\n",
    "    ex: stars['altnames'] = ['11 com b', 'Gliese 234', 'HD137'] -> stars['GL'] = 'GL 234'\"\"\"\n",
    "    prefixes = [\"GL \", \"Gliese \", \"NN \", \"WO \", \"GJ \"]\n",
    "    name = \"\"\n",
    "    for i in range(len(prefixes)):\n",
    "        if primary.startswith(prefixes[i]):\n",
    "            name = primary\n",
    "            break\n",
    "    if name == \"\" and alts != \"\":\n",
    "        for i in range(len(alts)):\n",
    "            for j in range(len(prefixes)):\n",
    "                if alts[i].startswith(prefixes[j]):\n",
    "                    name = alts[i]\n",
    "                    break\n",
    "            if name != \"\":\n",
    "                break\n",
    "    if name == \"\":\n",
    "        return np.nan\n",
    "    if name.startswith(\"GL\"):\n",
    "        name = \"Gl\" + name[2:]\n",
    "    elif name.startswith(\"WO\"):\n",
    "        name = \"Wo\" + name[2:]\n",
    "    elif name.startswith(\"Gliese\"):\n",
    "        name = \"GJ\" + name[6:]\n",
    "    return name"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 1,
   "id": "atmospheric-chester",
   "metadata": {},
   "outputs": [],
   "source": [
    "def getListOfNames(names):\n",
    "    \"\"\"Pass in a string from dataframe that has names surrounded by parentheses you'd like to extract the names from\n",
    "    ex: stars['name'] = Star('11 com b') -> stars['name'] = '11 com b'\"\"\"\n",
    "    temp = \"\"\n",
    "    while len(names) > 2:\n",
    "        start = names.find('(') + 2\n",
    "        end = names.find(')') - 1\n",
    "        temp += names[start:end] if len(temp) == 0 else \", \" + names[start:end]\n",
    "        names = names[end + 2 :]\n",
    "    return temp"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "id": "hawaiian-accused",
   "metadata": {},
   "outputs": [],
   "source": [
    "def listToString(s):  \n",
    "    \"\"\"pass in list, returns string\"\"\"\n",
    "    str1 = \",\" \n",
    "    return (str1.join(s)) "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "id": "adopted-macintosh",
   "metadata": {},
   "outputs": [],
   "source": [
    "def isNaN(x):\n",
    "    \"\"\"pass in a value you'd like to check to see if it is not a number, not to be confused with .isna() which returns checks if null\"\"\"\n",
    "    try:\n",
    "        float(x)\n",
    "    except:\n",
    "        return True\n",
    "    return False"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 14,
   "id": "confused-fortune",
   "metadata": {},
   "outputs": [],
   "source": [
    "def showheatmap(data):\n",
    "    fig, ax = plt.subplots(figsize=(35,30))\n",
    "    corr = data.corr().abs().round(3)\n",
    "    mask = np.triu(np.ones_like(corr, dtype=np.bool))\n",
    "    sns.heatmap(corr, annot=True, mask=mask, cmap='YlGn', ax=ax)\n",
    "    plt.setp(ax.get_xticklabels(), \n",
    "             rotation=45, \n",
    "             ha=\"right\",\n",
    "             rotation_mode=\"anchor\")\n",
    "    ax.set_title('Correlations')\n",
    "    fig.tight_layout()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 13,
   "id": "broadband-occasion",
   "metadata": {},
   "outputs": [],
   "source": [
    "def printVIF(data):\n",
    "    # VIF dataframe \n",
    "    vif_data = pd.DataFrame() \n",
    "    vif_data[\"feature\"] = data.columns \n",
    "\n",
    "    # calculating VIF for each feature \n",
    "    vif_data[\"VIF\"] = [variance_inflation_factor(data.values, i) \n",
    "                              for i in range(len(data.columns))] \n",
    "    print(vif_data)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 12,
   "id": "widespread-mother",
   "metadata": {},
   "outputs": [],
   "source": [
    "def is_number(s):\n",
    "    try:\n",
    "        float(s)\n",
    "        return True\n",
    "    except ValueError:\n",
    "        return False"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 11,
   "id": "constant-blade",
   "metadata": {},
   "outputs": [],
   "source": [
    "def showconfusionmatrix(y_train, y_hat_train, title):\n",
    "    fig, ax = plot_confusion_matrix(conf_mat=confusion_matrix(y_train, y_hat_train), colorbar=True, show_absolute=True, show_normed=True)\n",
    "    plt.title(f'{title} Data')\n",
    "    ax.set_xticks([0, 1])\n",
    "    ax.set_xticklabels(['True', 'False'])\n",
    "    ax.set_yticks([0, 1])\n",
    "    ax.set_yticklabels(['True', 'False'])\n",
    "    ax.set_ylabel('Actual Data')\n",
    "    ax.set_xlabel('Predicted Data')\n",
    "    plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 10,
   "id": "reduced-myanmar",
   "metadata": {},
   "outputs": [],
   "source": [
    "def print_reports(y_test, y_hat_test, y_train, y_hat_train):\n",
    "    print('                                                      ')\n",
    "    print('               Testing Report:')\n",
    "    report1 = classification_report(y_test, y_hat_test)\n",
    "    print(report1)\n",
    "    print('_____________________________________________________')\n",
    "    print('               Training Report:')\n",
    "    report2 = classification_report(y_train, y_hat_train)\n",
    "    print(report2)\n",
    "    print('_____________________________________________________')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 624,
   "id": "buried-bandwidth",
   "metadata": {},
   "outputs": [],
   "source": [
    "def showstar(star, zoom):\n",
    "    if zoom == 'out':\n",
    "        radius = (star['dist']/10)*.5\n",
    "        starra = Longitude(star['ra'], unit=u.deg)\n",
    "        stardec = np.array(star['dec']) * u.deg\n",
    "        stardist = np.array(star['dist']) * u.pc\n",
    "        s =  SkyCoord(ra=starra, dec=stardec, distance=stardist, obstime='2001-01-01T12:00:00')\n",
    "        plot_instance = MWPlot(mode='face-on', center=(0, 0)*u.kpc, radius=radius*u.kpc, unit=u.kpc, coord='galactic', annotation=False, rot180=False, grayscale=True)\n",
    "        plot_instance.dpi = 200\n",
    "        plot_instance.clim = (5., 15.)\n",
    "        plot_instance.imalpha = .5\n",
    "        plot_instance.s = radius/2\n",
    "        plot_instance.mw_scatter(-c.galactic.cartesian.x, c.galactic.cartesian.y,\n",
    "                                 c='y')\n",
    "        plot_instance.s = radius/2\n",
    "        plot_instance.mw_scatter(-p.galactic.cartesian.x, p.galactic.cartesian.y,\n",
    "                                 c='r')\n",
    "        plot_instance.s = float(star['dist']/2)\n",
    "        plot_instance.mw_scatter(-s.galactic.cartesian.x, s.galactic.cartesian.y,\n",
    "                                 c='g')\n",
    "        plt.show()\n",
    "    elif zoom == 'in':\n",
    "        radius = (star['dist']/10)*.01\n",
    "        starra = Longitude(star['ra'], unit=u.deg)\n",
    "        stardec = np.array(star['dec']) * u.deg\n",
    "        stardist = np.array(star['dist']) * u.pc\n",
    "        s =  SkyCoord(ra=starra, dec=stardec, distance=stardist, obstime='2001-01-01T12:00:00')\n",
    "        plot_instance = MWPlot(mode='face-on', center=(0, 0)*u.kpc, radius=radius*u.kpc, unit=u.kpc, coord='galactic', annotation=False, rot180=False, grayscale=True)\n",
    "        plot_instance.dpi = 200\n",
    "        plot_instance.clim = (5., 15.)\n",
    "        plot_instance.imalpha = .5\n",
    "        plot_instance.s = star['dist']/20\n",
    "        plot_instance.mw_scatter(-c.galactic.cartesian.x, c.galactic.cartesian.y,\n",
    "                                 c='y')\n",
    "        plot_instance.s = star['dist']/20\n",
    "        plot_instance.mw_scatter(-p.galactic.cartesian.x, p.galactic.cartesian.y,\n",
    "                                 c='r')\n",
    "        plot_instance.s = star['dist']*2.5\n",
    "        plot_instance.mw_scatter(-s.galactic.cartesian.x, s.galactic.cartesian.y,\n",
    "                                 c='g')\n",
    "        plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 643,
   "id": "incomplete-internship",
   "metadata": {},
   "outputs": [],
   "source": [
    "def predict_a_star(star):\n",
    "    \"\"\"Test if a star in the hyg dataset will have a planet!\n",
    "    pass in the star.loc[index_to_check] & answer some questions & the model will give you a yes or no!\"\"\"\n",
    "    print('Your star type is: ' + star.spect)\n",
    "    nan = star_csv.hd[0].astype(str)\n",
    "    if star.proper is np.nan:\n",
    "        if star.gl is np.nan:\n",
    "            if star.hd.astype(str) == nan:\n",
    "                if star.hr.astype(str) == nan:\n",
    "                    if star.hip.astype(str) == nan:\n",
    "                        starname = ''\n",
    "                    else:\n",
    "                        starname = f'HIP {star.hip}'\n",
    "                else:\n",
    "                    starname = f'HR {star.hr}'\n",
    "            else:\n",
    "                starname = f'HD {star.hd}'\n",
    "        else:\n",
    "            starname = f'GL {star.gl}'\n",
    "    else:\n",
    "        starname = f'Proper Name: {star.proper} '\n",
    "    s = star.to_frame().transpose().reset_index()\n",
    "    print('_____________________________________________________________________________________________')\n",
    "    print('                     ')\n",
    "    print('Please answer a few questions to help the program understand your star type.')\n",
    "    empty_frame = X.head(1)\n",
    "    for column in empty_frame.columns:\n",
    "        empty_frame.at[0, column] = 0\n",
    "    norms = ['dist', 'absmag', 'lum']\n",
    "    for col in norms:\n",
    "        empty_frame.at[0, col] = (s.at[0, col] - min(star_csv[col]))/ (max(star_csv[col]) - min(star_csv[col])) \n",
    "    emptyframe = empty_frame.fillna(0.0)\n",
    "    print('_____________________________________________________________________________________________')\n",
    "    print('                     ')\n",
    "    print('Does the type contain any capitalized letters? Please list all applicable seperated by spaces.')\n",
    "    print('Please do not include roman numerals, we will handle those seperatly.')\n",
    "    input4 = input()    \n",
    "    letters = [ 'B', 'C', 'F', 'G', 'K', 'M', 'RD', 'W', 'O', 'D']\n",
    "    if input4 == '':\n",
    "        pass \n",
    "    else: \n",
    "        input4 = input4.strip().upper().split()\n",
    "        for item in input4:\n",
    "            if item in letters:\n",
    "                if item == 'R':\n",
    "                    item = 'RD'\n",
    "                empty_frame.at[0, f'{item}'] = 1\n",
    "            else:\n",
    "                continue\n",
    "    print('_____________________________________________________________________________________________')\n",
    "    print('                 ')\n",
    "    print('Does it contain numbers? Please list all applicable seperated by spaces')\n",
    "    input2 = input()\n",
    "    if input2 == '':\n",
    "        pass\n",
    "    else:\n",
    "        list_ = input2.split()\n",
    "        for item in list_:\n",
    "            if is_number(item):\n",
    "                item = float(item)\n",
    "                item = math.floor(item)\n",
    "                empty_frame.at[0, f'{item}'] = 1\n",
    "    print('_____________________________________________________________________________________________')\n",
    "    print('                 ')\n",
    "    print('Does it contain roman numerals? Please list all applicable seperated by spaces')\n",
    "    lum_types = ['I', 'II', 'III', 'IV', 'V', 'VI']\n",
    "    input1 = input()\n",
    "    if input1 == '':\n",
    "        pass \n",
    "    else: \n",
    "        input1 = input1.strip().upper()\n",
    "        input1 = input1.split()\n",
    "    for item in input1:\n",
    "        if item in lum_types:\n",
    "            empty_frame.at[0, item] = 1\n",
    "    print('_____________________________________________________________________________________________')\n",
    "    print('                 ')\n",
    "    print('Does it contain any lowcase letters? Please list all applicable seperated by spaces.')\n",
    "    input5 = input()\n",
    "    lowerletters = [ 'sd', 'n', 'e', 'p', 'm']\n",
    "    if input5 == '':\n",
    "        pass \n",
    "    else: \n",
    "        input5 = input5.split()\n",
    "        for item in input5:\n",
    "            item = item.lower()\n",
    "            if item in lowerletters:\n",
    "                if item == 's':\n",
    "                    item = 'sd'\n",
    "                empty_frame.at[0, f'{item}'] = 1\n",
    "            else:\n",
    "                continue\n",
    "    print('_____________________________________________________________________________________________')\n",
    "    print('                     ')\n",
    "    print('Does it contain any special symbols? Please list all applicable seperated by spaces.')\n",
    "    print('Please substitute 1 in place of \"...\", 2 in place of \"+\", and 3  in place of \":\"')\n",
    "    input3 = input()\n",
    "    if input3 == '':\n",
    "        pass\n",
    "    else:\n",
    "        list_ = input3.strip().split()\n",
    "        for item in list_:\n",
    "            if  item == '1':\n",
    "                col = '...'\n",
    "                empty_frame.at[0, col] = 1\n",
    "            elif item == '2':\n",
    "                col = '+'\n",
    "                empty_frame.at[0, col] = 1\n",
    "            elif item == '3':\n",
    "                col = ':'\n",
    "                empty_frame.at[0, col] = 1\n",
    "    print('Thank you for answering.')\n",
    "    if final_model.predict(empty_frame)[0] == 1:\n",
    "        print(' ')\n",
    "        print(f'Your star, {starname} is unlikely to have a planet. :(')\n",
    "    if final_model.predict(empty_frame)[0] == 0:\n",
    "        print(' ')\n",
    "        print(f'Your star, {starname} is very likely to have a planet. :)')\n",
    "    return empty_frame.copy() "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 8,
   "id": "cathedral-spain",
   "metadata": {},
   "outputs": [],
   "source": [
    "def getbestlogparams(X_train, y_train):\n",
    "    pipe = Pipeline([('classifier' , LogisticRegression())])\n",
    "\n",
    "    param_grid = [\n",
    "        {'classifier' : [LogisticRegression()],\n",
    "         'classifier__penalty' : ['l1', 'l2'],\n",
    "         'classifier__C' : np.logspace(-4, 4, 20),\n",
    "         'classifier__fit_intercept' : [True, False],\n",
    "         'classifier__solver' : ['liblinear', 'newton-cg', 'sag', 'saga', 'lbfgs']}]\n",
    "\n",
    "    # Create grid search object\n",
    "    clf = GridSearchCV(pipe, param_grid, cv=10, estimator='recall',  n_jobs=-1)\n",
    "\n",
    "    # Fit on data\n",
    "    best_clf = clf.fit(X_train, y_train)\n",
    "    list_ = [x for x in best_clf.best_params_.values()]\n",
    "    return list_[0]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 7,
   "id": "flush-bridge",
   "metadata": {},
   "outputs": [],
   "source": [
    "def show_roc_plot(fpr, tpr):\n",
    "    sns.set_style('darkgrid', {'axes.facecolor': '0.9'})\n",
    "\n",
    "    print('AUC: {}'.format(auc(fpr, tpr)))\n",
    "    plt.figure(figsize=(10, 8))\n",
    "    lw = 2\n",
    "    plt.plot(fpr, tpr, color='darkorange',\n",
    "             lw=lw, label='ROC curve')\n",
    "    plt.plot([0, 1], [0, 1], color='navy', lw=lw, linestyle='--')\n",
    "    plt.xlim([0.0, 1.0])\n",
    "    plt.ylim([0.0, 1.05])\n",
    "    plt.yticks([i/20.0 for i in range(21)])\n",
    "    plt.xticks([i/20.0 for i in range(21)])\n",
    "    plt.xlabel('False Positive Rate')\n",
    "    plt.ylabel('True Positive Rate')\n",
    "    plt.title('Receiver operating characteristic (ROC) Curve')\n",
    "    plt.legend(loc='lower right')\n",
    "    plt.show()"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.8.6"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
